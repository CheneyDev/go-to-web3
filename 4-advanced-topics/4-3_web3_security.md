# 4.3: Web3 安全

在 Web3 的世界里，安全是第一位的。智能合约一旦部署，其代码和逻辑通常是不可更改的，且掌管着真金白银的资产。一个微小的漏洞都可能导致数百万甚至上亿美元的损失。因此，理解常见的攻击向量并遵循安全开发的最佳实践至关重要。

## 1. 常见的智能合约漏洞

### 1.1 重入攻击 (Re-entrancy)

这是以太坊历史上最臭名昭著的漏洞之一，直接导致了 The DAO 事件和以太坊的硬分叉。

- **原理**: 当一个合约 A 调用另一个合约 B 的函数时，合约 B 可以在其函数执行完成前，反过来"重入"合约 A 的函数，从而在合约 A 的状态更新前，多次执行恶意操作。

- **攻击场景 (简易版)**:
  1.  一个银行合约 A 有 `withdraw` 函数，允许用户提款。
  2.  `withdraw` 函数的逻辑是：
      a. 检查用户余额是否充足。
      b. 向用户地址发送 ETH (`call.value()`)。
      c. 更新用户的余额记录，将其减去提款金额。
  3.  攻击者创建一个恶意合约 B，并存入一些钱到银行合约 A。
  4.  攻击者调用合约 B 的函数，该函数再去调用银行合约 A 的 `withdraw`。
  5.  当银行合约 A 执行到第 2.b 步，向合约 B 发送 ETH 时，会触发合约 B 的 `fallback` 函数。
  6.  攻击者在 `fallback` 函数里再次调用银行合约 A 的 `withdraw` 函数。
  7.  由于此时银行合约 A 还没来得及执行第 2.c 步（更新余额），所以它认为攻击者的余额仍然充足，于是再次向合约 B 发送 ETH。
  8.  这个过程会一直重复，直到银行合约 A 的资金被全部提空。

### 1.2 整数溢出/下溢 (Integer Overflow/Underflow)

- **原理**: Solidity 的整数类型（如 `uint8`, `uint256`）有固定的取值范围。当一个数进行算术运算后超出了其最大值（溢出）或最小值（下溢）时，它会像里程表一样"翻转"。
  - `uint8` 的最大值是 255。`255 + 1` 会变成 `0` (上溢)。
  - `uint8` 的最小值是 0。`0 - 1` 会变成 `255` (下溢)。

- **攻击场景**:
  - 一个 ERC-20 代币合约的 `transfer` 函数中，若 `require(balance[msg.sender] >= _value)` 检查存在逻辑漏洞或被绕过，攻击者可以通过传入一个巨大的 `_value`，使得自己的余额在扣减后发生下溢，变成一个极大的数字。

- **防范**: 从 Solidity 0.8.0 版本开始，编译器内置了对整数溢出的检查，会在发生溢出时自动抛出错误。对于低于 0.8.0 的版本，必须使用 `SafeMath` 等库来对所有算术运算进行安全包装。

### 1.3 访问控制错误 (Access Control Errors)

- **原理**: 合约中的关键函数（如 `mint`, `burn`, `setOwner` 等）没有被正确地保护起来，导致任何攻击者都可以调用它们。

- **常见错误**:
  - **忘记 `onlyOwner`**: 忘记给敏感函数添加 `onlyOwner` 或类似的修饰符。
  - **错误的 `tx.origin` 判断**: 使用 `tx.origin` 而不是 `msg.sender` 来进行身份验证。`tx.origin` 是交易的原始发起者，如果用户 A 调用了合约 B，合约 B 再调用合约 C，那么在合约 C 中，`msg.sender` 是合约 B，而 `tx.origin` 是用户 A。恶意合约可以诱导用户发起交易，从而绕过基于 `tx.origin` 的检查。**永远不要使用 `tx.origin` 进行授权。**
  - **`public` vs `external`**: 错误地将本应是 `internal` 或 `private` 的函数声明为 `public`，使其可以被外部调用。

## 2. 安全开发最佳实践

### 2.1 使用经过审计的合约库

- **不要重复造轮子**: 对于 ERC-20, ERC-721, `Ownable` (所有权), `Pausable` (紧急暂停) 等标准功能，务必使用像 [OpenZeppelin](https://www.openzeppelin.com/contracts) 或 [Solmate](https://github.com/transmissions11/solmate) 这样经过社区广泛使用和专业安全公司审计的开源合约库。这些库是智能合约开发的事实标准，能帮你避免大量低级错误。

### 2.2 "检查-生效-交互" 模式 (Checks-Effects-Interactions Pattern)

这是防止重入攻击的黄金法则。在编写函数时，必须严格遵循以下顺序：

1.  **检查 (Checks)**: 首先，执行所有的前置条件检查 (`require`, `if` 判断)。例如，检查调用者是否有权限、余额是否足够、输入参数是否合法等。
2.  **生效 (Effects)**: 然后，更新所有会影响合约状态的变量。例如，更新用户的余额、铸造新的代币等。
3.  **交互 (Interactions)**: 最后，再与外部合约或地址进行交互（例如，发送 ETH、调用其他合约的函数）。

通过在外部交互 **之前** 更新状态，即使外部调用发生重入，合约的状态也已经是最新的了，重入的函数会在第一步"检查"时就因为条件不满足而失败。

### 2.3 单元测试与代码审计

- **100% 测试覆盖率**: 使用 Hardhat 或 Foundry 为你的合约编写全面的单元测试，特别是要针对所有可能的边缘情况和潜在的攻击向量进行测试。
- **聘请专业审计**: 对于任何处理重要资产的 DApp，在主网上线前，都必须聘请至少一家专业的 Web3 安全审计公司进行全面的代码审计。审计是发现潜在漏洞的最后一道，也是最重要的一道防线。
- **漏洞赏金计划 (Bug Bounty)**: 发布一个漏洞赏金计划，激励白帽黑客在你部署后帮助你发现并负责任地报告漏洞，而不是利用它。

安全是一个持续的过程，而不是一个一次性的检查。保持对最新攻击手法的学习，遵循社区的最佳实践，是每个 Web3 开发者的必修课。 